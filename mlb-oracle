#!/bin/env python3
""" Predict the MLB scores of the day """

"""Towards 1.0

* Print team names at once with 'PREDICTING...'
  and then replace with result.

* Highlight the favored team

* More information on error, i.e. not just 'no prediction'

* Implement mode that also tells you the lineups

"""


import argparse
import datetime
import logging
import subprocess
import sys
import tempfile

import statsapi

import ballgame


def colored_msg(code, msg):
    """ Color `msg' in ttys according to win probability """
    return "\033[{}m{}\033[0m".format(code, msg) if code else msg

def colored(winp, msg):
    """ Color `msg' in ttys according to win probability """
    code = colormap(winp)
    return "\033[{}m{}\033[0m".format(code, msg) if code else msg


def bold(msg):
    """ Bold `msg' in ttys according to win probability """
    return "\033[1m{}\033[0m".format(msg)


WHITE = 37
RED = 31
YELLOW = 33
GREEN = 32
CYAN = 36
BLUE = 34

def colormap(winprob):
    """ Mapping fron win probability to tty color code """
    if winprob < 0.25:
        return WHITE
    if 0.25 <= winprob < 0.45:
        return RED
    if 0.45 <= winprob < 0.55:
        return YELLOW
    if 0.55 <= winprob < 0.75:
        return GREEN
    if 0.75 <= winprob:  # pylint: disable=misplaced-comparison-constant
        return CYAN
    return None

def predicting_line(game):
    line = bold('    PREDICTING...    ')
    return '{:>25} {} {}'.format(game['away_name'], line, game['home_name'])


def postponed_line(game):
    line = colored_msg(BLUE, bold('    POSTPONED        '))
    return '{:>25} {} {}'.format(game['away_name'], line, game['home_name'])


def clear_line():
    print("\033[2K\r", end='')


def prediction_line(game, hwp):
    """ Format the prediction message for the game """
    if hwp is None:
        line = bold('    NO PREDICTION    ')

    else:
        nboxes_per_team = 10
        awp = 1 - hwp
        nfull_h = round(hwp * nboxes_per_team)
        nfull_a = round(awp * nboxes_per_team)

        # Away
        line = ''
        for _ in range(nboxes_per_team - nfull_a):
            line += '□'
        subline = ''
        for _ in range(nfull_a):
            subline += '■'
        line += colored(awp, subline)

        # Separator
        line += ' '

        # Home
        subline = ''
        for _ in range(nfull_h):
            subline += '■'
        line += colored(hwp, subline)
        for _ in range(nboxes_per_team - nfull_h):
            line += '□'

    return '{:>25} {} {}'.format(game['away_name'], line, game['home_name'])


# TODO move to ballgame.py
def dump_lineup(team, path):
    """ Save lineup of `team' to `path' in format understood by ballgame.cxx """
    with open(path, 'w') as outf:
        outf.write('{} {} {} {}\n'.format(
            team.pitcher['H'],
            team.pitcher['BB'],
            team.pitcher['SO'],
            team.pitcher['BF']
        ))
        for btr in team.batters:
            outf.write('{} {} {} {} {} {} {}\n'.format(
                btr['AB'],
                btr['H'],
                btr['2B'],
                btr['3B'],
                btr['HR'],
                btr['SO'],
                btr['BA'],
            ))


def predict(away, home):
    """ Run the ballgame.cxx prediction code """
    tmp_away = tempfile.NamedTemporaryFile()
    tmp_home = tempfile.NamedTemporaryFile()

    if not (away and home):
        # TODO gather info to debug
        logging.debug('Technical problem!')
        return None

    dump_lineup(away, tmp_away.name)
    dump_lineup(home, tmp_home.name)

    try:
        logging.info('Predicting...')
        hwp = ballgame.run_simulations(tmp_away.name, tmp_home.name)
    finally:
        tmp_away.close()
        tmp_home.close()

    logging.info('Home win probability: %f', hwp)
    return hwp


def lineup(game_data, key):
    """ return None if lineup unavailable, otherwise return Team object """

    if len(game_data[key + 'Pitchers']) == 1:
        return None

    startp = game_data[key + 'Pitchers'][1]
    logging.info('Fetching pitching stats for %s', startp['namefield'])
    startpd = statsapi.player_stat_data(
        startp['personId'],
        group='pitching',
        type='career'
    )
    stats = startpd['stats'][0]['stats']

    pitcher = ballgame.pitcher(
        startp['namefield'],
        stats['hits'],
        stats['baseOnBalls'],
        stats['strikeOuts'],
        stats['battersFaced']
    )

    batters = []

    btrs = game_data[key + 'Batters'][1:]
    if not btrs:
        return None

    for batter in game_data[key + 'Batters'][1:]:
        if batter['namefield'][0].isdigit():
            logging.info(
                'Fetching hitting stats for %s',
                batter['namefield']
            )
            try:
                btrd = statsapi.player_stat_data(
                    batter['personId'],
                    group='hitting',
                    type='career'
                )
            except KeyError:
                return None
            stats = btrd['stats'][0]['stats']
            batters.append(ballgame.batter(
                batter['namefield'],
                stats['atBats'],
                stats['hits'],
                stats['doubles'],
                stats['triples'],
                stats['homeRuns'],
                stats['strikeOuts'],
                float('0' + stats['avg']),
            ))
    return ballgame.Team(pitcher, batters)


def oracle(game):
    """ Predict outcome of `game' """
    logging.info(
        'Oracle will now predict %s vs %s',
        game['away_name'],
        game['home_name']
    )
    # print(game['status']) # 'Final'
    if game['status'] == 'Postponed':
        print(postponed_line(game))
        return True

    logging.debug('Fetching game data')
    line = colored_msg(WHITE, bold('  FETCHING DATA...   '))
    print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']), end='')
    game_data = statsapi.boxscore_data(game['game_id'])
    logging.debug('Result: %s', game_data is not None)

    team_away = team_home = None
    try:
        team_away = lineup(game_data, 'away')
        team_home = lineup(game_data, 'home')
    except:
        logging.exception('Error encountered while fetching lineups')
        line = colored_msg(RED, bold('   FRONTEND ERROR    '))
        print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']))
        return

    if (not team_away) and (not team_home):
        line = colored_msg(YELLOW, bold('   MISSING LINEUPS   '))
        print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']))
        return True

    if not team_away:
        line = colored_msg(YELLOW, bold('   MISSING LINEUP A  '))
        print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']))
        return True

    if not team_home:
        line = colored_msg(YELLOW,bold('   MISSING LINEUP H  '))
        print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']))
        return True

    print('\r' + predicting_line(game), end='')
    sys.stdout.flush()

    try:
        home_win_probability = predict(team_away, team_home)
    except:
        # clear_line()
        logging.exception('backend error')
        line =  colored_msg(RED, bold('   BACKEND ERROR    '))
        print('\r{:>25} {} {}'.format(game['away_name'], line, game['home_name']))
        return

    # clear_line()
    print('\r' + prediction_line(game, home_win_probability))
    return True


def _configure_logging(path):
    if path:
        logging.basicConfig(
            filename=path,
            filemode='a',
            format='[%(asctime)s %(levelname)s %(process)d/%(module)s.%(funcName)s] %(message)s',
            level=logging.WARNING
        )
    else:
        logging.basicConfig(
            filename=path,
            filemode='a',
            format='[%(asctime)s %(levelname)s %(process)d/%(module)s.%(funcName)s] %(message)s',
            level=logging.CRITICAL
        )


def _get_args():
    args = argparse.ArgumentParser()
    args.add_argument('--log', action='store_true')
    args.add_argument('-d', '--date', default=datetime.date.today().isoformat())
    # args.add_argument('-l', '--lineups', action='store_true')
    return args.parse_args()


def _main():
    args = _get_args()
    _configure_logging('/dev/stderr' if args.log else None)
    logging.info('mlb-oracle version alpha.1')
    date = datetime.date.fromisoformat(args.date)
    logging.info('Predictions for %s', date.isoformat())

    logging.debug('Fetching schedule')
    sched = statsapi.schedule(start_date=date.strftime('%m/%d/%Y'))
    logging.debug('Result: %s', sched is not None)

    err = False
    for game in sched:
        err |= not oracle(game)

    if err:
        if not args.log:
            print(colored_msg(RED, '**** There were errors, run with --log for potential details'))
        else:
            print(colored_msg(RED, '**** There were errors'))
        return 1

    return 0

if __name__ == '__main__':
    exit(_main())
