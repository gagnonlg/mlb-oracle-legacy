#!/bin/env python3
""" Predict the MLB scores of the day """

import argparse
import datetime
import logging
import subprocess
import tempfile

import statsapi

import ballgame


def colored(winp, msg):
    """ Color `msg' in ttys according to win probability """
    code = colormap(winp)
    return "\033[{}m{}\033[0m".format(code, msg) if code else msg


def bold(msg):
    """ Bold `msg' in ttys according to win probability """
    return "\033[1m{}\033[0m".format(msg)


def colormap(winprob):
    """ Mapping fron win probability to tty color code """
    if winprob < 0.25:
        return 37  # White
    if 0.25 <= winprob < 0.45:
        return 31  # Red
    if 0.45 <= winprob < 0.55:
        return 33  # Yellow
    if 0.55 <= winprob < 0.75:
        return 32  # Green
    if 0.75 <= winprob:  # pylint: disable=misplaced-comparison-constant
        return 36  # Cyan
    return None


def prediction_line(game, hwp):
    """ Format the prediction message for the game """
    if hwp is None:
        line = bold('    NO PREDICTION    ')

    else:
        nboxes_per_team = 10
        awp = 1 - hwp
        nfull_h = round(hwp * nboxes_per_team)
        nfull_a = round(awp * nboxes_per_team)

        # Away
        line = ''
        for _ in range(nboxes_per_team - nfull_a):
            line += '□'
        subline = ''
        for _ in range(nfull_a):
            subline += '■'
        line += colored(awp, subline)

        # Separator
        line += ' '

        # Home
        subline = ''
        for _ in range(nfull_h):
            subline += '■'
        line += colored(hwp, subline)
        for _ in range(nboxes_per_team - nfull_h):
            line += '□'

    return '{:>25} {} {}'.format(game['away_name'], line, game['home_name'])


def dump_lineup(team, path):
    """ Save lineup of `team' to `path' in format understood by ballgame.cxx """
    with open(path, 'w') as outf:
        outf.write('{} {} {} {}\n'.format(
            team.pitcher['H'],
            team.pitcher['BB'],
            team.pitcher['SO'],
            team.pitcher['BF']
        ))
        for btr in team.batters:
            outf.write('{} {} {} {} {} {} {}\n'.format(
                btr['AB'],
                btr['H'],
                btr['2B'],
                btr['3B'],
                btr['HR'],
                btr['SO'],
                btr['BA'],
            ))


def predict(away, home):
    """ Run the ballgame.cxx prediction code """
    tmp_away = tempfile.NamedTemporaryFile()
    tmp_home = tempfile.NamedTemporaryFile()

    if not (away and home):
        # TODO gather info to debug
        logging.debug('Technical problem!')
        return None

    dump_lineup(away, tmp_away.name)
    dump_lineup(home, tmp_home.name)

    try:
        logging.info('Predicting...')
        # TODO better handling of code path
        outp = subprocess.check_output(
            ['./ballgame', tmp_away.name, tmp_home.name]
        )
    finally:
        tmp_away.close()
        tmp_home.close()

    if outp:
        logging.info('Home win probability: %f', float(outp.strip()))
        return float(outp.strip())

    return None


def lineup(game_data, key):
    """ return None if lineup unavailable, otherwise return Team object """

    if len(game_data[key + 'Pitchers']) == 1:
        return None

    startp = game_data[key + 'Pitchers'][1]
    logging.info('Fetching pitching stats for %s', startp['namefield'])
    try:
        startpd = statsapi.player_stat_data(
            startp['personId'],
            group='pitching',
            type='career'
        )
    except KeyError:
        return None
    stats = startpd['stats'][0]['stats']

    pitcher = ballgame.pitcher(
        startp['namefield'],
        stats['hits'],
        stats['baseOnBalls'],
        stats['strikeOuts'],
        stats['battersFaced']
    )

    batters = []

    btrs = game_data[key + 'Batters'][1:]
    if not btrs:
        return None

    for batter in game_data[key + 'Batters'][1:]:
        if batter['namefield'][0].isdigit():
            logging.info(
                'Fetching hitting stats for %s',
                batter['namefield']
            )
            try:
                btrd = statsapi.player_stat_data(
                    batter['personId'],
                    group='hitting',
                    type='career'
                )
            except KeyError:
                return None
            stats = btrd['stats'][0]['stats']
            batters.append(ballgame.batter(
                batter['namefield'],
                stats['atBats'],
                stats['hits'],
                stats['doubles'],
                stats['triples'],
                stats['homeRuns'],
                stats['strikeOuts'],
                float('0' + stats['avg']),
            ))
    return ballgame.Team(pitcher, batters)


def oracle(game):
    """ Predict outcome of `game' """
    logging.info(
        'Oracle will now predict %s vs %s',
        game['away_name'],
        game['home_name']
    )

    logging.debug('Fetching game data')
    game_data = statsapi.boxscore_data(game['game_id'])
    logging.debug('Result: %s', game_data is not None)

    team_away = lineup(game_data, 'away')
    team_home = lineup(game_data, 'home')

    home_win_probability = predict(team_away, team_home)
    print(prediction_line(game, home_win_probability))


def _configure_logging(path):
    if path:
        logging.basicConfig(
            filename=path,
            filemode='a',
            format='[%(asctime)s %(levelname)s %(process)d/%(module)s.%(funcName)s] %(message)s',
            level=logging.INFO
        )


def _get_args():
    args = argparse.ArgumentParser()
    args.add_argument('--log')
    args.add_argument('-d', '--date', default=datetime.date.today().isoformat())
    # args.add_argument('-l', '--lineups', action='store_true')
    return args.parse_args()


def _main():
    args = _get_args()
    _configure_logging(args.log)
    logging.info('mlb-oracle version alpha.1')
    date = datetime.date.fromisoformat(args.date)
    logging.info('Predictions for %s', date.isoformat())

    logging.debug('Fetching schedule')
    sched = statsapi.schedule(start_date=date.strftime('%m/%d/%Y'))
    logging.debug('Result: %s', sched is not None)

    for game in sched:
        oracle(game)

if __name__ == '__main__':
    _main()
